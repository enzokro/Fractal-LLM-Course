# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/02_nbdev.ipynb.

# %% auto 0
__all__ = ['SentimentPipeline']

# %% ../../nbs/02_nbdev.ipynb 37
# cell where we import the pieces of our pipeline.
from transformers import AutoConfig
from transformers import AutoTokenizer
from transformers import AutoModelForSequenceClassification

# %% ../../nbs/02_nbdev.ipynb 40
class SentimentPipeline:
    """
    Docstring, inserted on the fly!
    """
    def __init__(self, model_name):
        """
        Sentiment Analysis pipeline.
        """
        self.model_name = model_name
        self.config = AutoConfig.from_pretrained(self.model_name)
        self.tokenizer = AutoTokenizer.from_pretrained(self.model_name)
        self.model = AutoModelForSequenceClassification.from_pretrained(self.model_name)


    def preprocess(self, text: str):
        """
        Sends `text` through the LLM's tokenizer.  
        The tokenizers turns words and characters into special inputs for the LLM.
        """
        tokenized_inputs = self.tokenizer(text, return_tensors='pt')
        return tokenized_inputs
    

    def forward(self, text: str):
        """
        First we preprocess the `text` into tokens.
        Then we send the `token_inputs` to the model.
        """
        token_inputs = self.preprocess(text)
        outputs = self.model(**token_inputs)
        return outputs
    

    def process_outputs(self, outs):
        """
        Here is where HuggingFace does the most for us via `pipeline`.  
        """
        # grab the raw "scores" that from the model for Positive and Negative labels
        logits = outs.logits

        # find the strongest label score, aka the model's decision
        pred_idx = logits.argmax(1).item()

        # use the `config` object to find the class label
        pred_label = self.config.id2label[pred_idx]  

        # calculate the human-readable number for the score
        pred_score = logits.softmax(-1)[:, pred_idx].item()

        return {
            'label': pred_label,
            'score': pred_score, 
        }
    
    def __call__(self, text: str):
        model_outs = self.forward(text)
        preds = self.process_outputs(model_outs)
        return preds
    
    def __repr__(self):
        return f"SentimentAnalysis_{self.model_name}"


